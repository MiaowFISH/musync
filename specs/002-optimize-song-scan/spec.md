# Feature Specification: 优化歌曲扫描机制

**Feature Branch**: `002-optimize-song-scan`  
**Created**: 2025-12-31  
**Status**: Draft  
**Input**: User description: "修复并优化歌曲扫描机制：1.优化元数据读取避免全文件读取 2.支持无songId歌曲的数据库存储"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 快速扫描大型音乐库 (Priority: P1)

作为拥有大量本地音乐的用户，我希望扫描操作能够快速完成，不会因为读取大量文件而导致长时间等待或硬盘过度负载。

**Why this priority**: 当前扫描1150首歌曲（35.2GB）需要读取全部文件内容到内存，这是最严重的性能问题，直接影响用户体验和硬件寿命。

**Independent Test**: 可以通过扫描包含1000+首歌曲的目录来独立测试，验证扫描时间和IO读取量是否显著降低。

**Acceptance Scenarios**:

1. **Given** 一个包含1000首FLAC歌曲的目录，**When** 用户执行扫描操作，**Then** 系统在合理时间内完成扫描，不读取每个文件的完整内容
2. **Given** 一个包含混合格式（MP3、FLAC、OGG）的音乐目录，**When** 用户执行扫描操作，**Then** 系统能够正确识别所有支持格式的元数据
3. **Given** 一个慢速存储设备（如网络驱动器或机械硬盘），**When** 用户执行扫描操作，**Then** 扫描速度相比全文件读取方式有显著提升

---

### User Story 2 - 存储无在线ID的本地歌曲 (Priority: P1)

作为用户，我希望所有扫描到的本地歌曲都能被记录到数据库中，即使它们还没有与在线歌单匹配获得songId。

**Why this priority**: 当前系统无法存储没有songId的歌曲，导致大部分本地歌曲信息丢失，这是核心功能缺陷。

**Independent Test**: 可以通过扫描包含纯本地歌曲（无songId）的目录，验证所有歌曲是否被正确存储到数据库。

**Acceptance Scenarios**:

1. **Given** 一个包含无songId本地歌曲的目录，**When** 用户执行扫描操作并选择更新数据库，**Then** 所有识别成功的歌曲都被存储到数据库中
2. **Given** 数据库中已存在无songId的歌曲记录，**When** 该歌曲后续通过在线匹配获得songId，**Then** 系统能够更新该记录的songId而不创建重复条目
3. **Given** 数据库中存在多首同名但不同路径的歌曲，**When** 用户查询数据库，**Then** 系统能够正确区分这些歌曲

---

### User Story 3 - 增量扫描更新 (Priority: P2)

作为用户，当我的音乐库有新增或修改时，我希望系统只处理变化的文件，而不是重新扫描整个目录。

**Why this priority**: 增量扫描可以进一步提升用户体验，但依赖于P1功能的正确实现。

**Independent Test**: 可以通过添加新文件到已扫描目录，验证系统是否只处理新增文件。

**Acceptance Scenarios**:

1. **Given** 一个已扫描过的音乐目录，**When** 用户添加新歌曲后再次扫描，**Then** 系统能够识别新增歌曲并添加到数据库
2. **Given** 一个已扫描过的音乐目录，**When** 用户删除某首歌曲后再次扫描，**Then** 系统能够标记该歌曲为已删除状态
3. **Given** 一个已扫描过的音乐目录，**When** 用户修改某首歌曲的元数据后再次扫描，**Then** 系统能够检测到变化并更新数据库记录

---

### Edge Cases

- 当音频文件元数据损坏或不完整时，系统应回退到文件名解析
- 当文件正在被其他程序使用时，扫描应跳过该文件并记录警告
- 当同一首歌曲存在于不同目录（文件名相同但路径不同）时，系统应分别记录
- ~~当数据库中的记录对应的文件被移动到新位置时，系统应能够通过元数据匹配识别~~ *(Out of scope for this feature - requires content hashing which conflicts with performance goals)*

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统必须使用流式读取方式解析音频元数据，仅读取文件头部必要的字节数而非整个文件
- **FR-002**: 系统必须支持存储没有songId的本地歌曲记录
- **FR-003**: 系统必须使用唯一标识符（如文件路径）来区分不同的本地歌曲记录
- **FR-004**: 系统必须支持后续为已存储的歌曲添加或更新songId
- **FR-005**: 系统必须在扫描时记录每首歌曲的文件修改时间，用于增量扫描判断
- **FR-006**: 系统必须在扫描操作中提供进度反馈，显示当前处理的文件
- **FR-007**: 系统必须支持跳过已扫描且未修改的文件（增量扫描模式）
- **FR-008**: 系统必须保持与现有CLI命令和输出格式的兼容性

### Key Entities

- **LocalTrack**: 本地音轨信息，包含文件路径、歌曲名、艺术家、格式、音质等属性，songId为可选字段
- **SyncRecord**: 同步记录，存储本地歌曲信息，需要支持无songId的记录，使用文件路径作为主要标识符
- **Database**: 数据库结构，存储所有同步记录，需要支持按路径和按songId两种查询方式

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 扫描1000首歌曲（约30GB）的时间相比全文件读取方式减少80%以上
- **SC-002**: 扫描操作的内存峰值使用量不超过200MB，无论音乐库大小
- **SC-003**: 100%的识别成功歌曲（无论是否有songId）都能被正确存储到数据库
- **SC-004**: 用户能够在后续操作中为任意已存储歌曲关联songId，且不产生重复记录
- **SC-005**: 增量扫描时，未修改的文件不会被重新读取和解析

## Assumptions

- 用户的音频文件元数据存储在文件头部，符合各格式的标准规范
- 文件系统提供可靠的文件修改时间信息用于增量扫描判断
- 用户音乐库中不会存在完全相同路径的不同文件（路径可作为唯一标识）
- 现有的music-metadata库支持流式读取模式
